"""
ARQ Worker para processar mensagens em fila
Evita rate limits do Gemini processando no m√°ximo N mensagens simult√¢neas
"""
import asyncio
import time
import random
import re
from typing import Dict, Any
from arq import create_pool
from arq.connections import RedisSettings

from config.settings import settings
from config.logger import setup_logger
from agent_multiagent import run_agent
from tools.whatsapp_api import WhatsAppAPI

logger = setup_logger(__name__)
whatsapp = WhatsAppAPI()


async def process_message(ctx: Dict[str, Any], telefone: str, mensagem: str, message_id: str = None) -> str:
    """
    Processa uma mensagem do WhatsApp (fun√ß√£o executada pelo worker ARQ).
    
    Este √© o equivalente ao antigo `process_async` do server.py, mas rodando
    como um job ARQ na fila.
    
    Args:
        ctx: Contexto ARQ (cont√©m pool Redis, etc)
        telefone: N√∫mero do cliente
        mensagem: Texto da mensagem
        message_id: ID da mensagem (para mark_as_read)
    
    Returns:
        Status da execu√ß√£o
    """
    try:
        num = re.sub(r"\D", "", telefone)
        
        # 1. Simular "Lendo" (Delay Humano)
        tempo_leitura = random.uniform(2.0, 4.0)
        await asyncio.sleep(tempo_leitura)
        
        # 2. Marcar como LIDO (Azul) - Suporte a m√∫ltiplos IDs
        if message_id:
            mids = message_id if isinstance(message_id, list) else [message_id]
            logger.info(f"üëÄ Marcando chat {telefone} como lido... (MIDs: {len(mids)})")
            
            for mid in mids:
                if mid:
                    whatsapp.mark_as_read(telefone, message_id=mid)
                    # Pequeno delay entre requests para n√£o floodar (se forem muitos)
                    if len(mids) > 1: await asyncio.sleep(0.1)
            
            await asyncio.sleep(0.8)  # Delay t√°tico para UX
        
        # 3. Come√ßar a "Digitar"
        whatsapp.send_presence(num, "composing")
        
        # 3.5 Processar m√≠dia se for placeholder ([MEDIA:TYPE:ID])
        if mensagem.startswith("[MEDIA:"):
            try:
                # Parse: [MEDIA:IMAGE:3EB08C4C6042...]
                parts = mensagem.strip("[]").split(":")
                media_type = parts[1].lower() if len(parts) > 1 else "image"
                media_id = parts[2] if len(parts) > 2 else None
                
                if media_id:
                    logger.info(f"üì∑ Processando m√≠dia {media_type}: {media_id}")
                    
                    if media_type == "image":
                        # Importar fun√ß√£o de an√°lise do server.py
                        from server import analyze_image
                        analysis = analyze_image(media_id, None)
                        if analysis:
                            mensagem = f"[An√°lise da imagem]: {analysis}"
                            logger.info(f"‚úÖ Imagem analisada: {analysis[:50]}...")
                        else:
                            mensagem = "[Imagem recebida, mas n√£o foi poss√≠vel analisar]"
                    elif media_type == "audio":
                        from server import transcribe_audio
                        transcription = transcribe_audio(media_id)
                        if transcription:
                            mensagem = f"[√Åudio]: {transcription}"
                            logger.info(f"‚úÖ √Åudio transcrito: {transcription[:50]}...")
                        else:
                            mensagem = "[√Åudio recebido, mas n√£o foi poss√≠vel transcrever]"
                    elif media_type == "document":
                        from server import process_pdf
                        pdf_text = process_pdf(media_id)
                        if pdf_text:
                            mensagem = f"[Conte√∫do PDF]: {pdf_text[:1200]}"
                        else:
                            mensagem = "[Documento/PDF recebido]"
            except Exception as e:
                logger.error(f"‚ùå Erro ao processar m√≠dia: {e}")
                mensagem = "[M√≠dia recebida, erro ao processar]"
        
        # 4. Processamento IA (s√≠ncrono - run_agent n√£o √© async)
        # Rodamos em thread_pool para n√£o bloquear o event loop
        loop = asyncio.get_event_loop()
        res = await loop.run_in_executor(None, run_agent, telefone, mensagem)
        txt = res.get("output", "Erro ao processar.")
        
        # 5. Parar "Digitar"
        whatsapp.send_presence(num, "paused")
        await asyncio.sleep(0.5)
        
        # 6. Enviar Mensagem (tamb√©m s√≠ncrono)
        await loop.run_in_executor(None, _send_whatsapp_message, telefone, txt)
        
        logger.info(f"‚úÖ Mensagem processada com sucesso: {telefone}")
        return "success"
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao processar mensagem de {telefone}: {e}", exc_info=True)
        # Parar digitando em caso de erro
        try:
            whatsapp.send_presence(telefone, "paused")
        except:
            pass
        raise  # ARQ vai fazer retry autom√°tico


def _send_whatsapp_message(telefone: str, mensagem: str) -> bool:
    """Helper s√≠ncrono para enviar mensagem (com detec√ß√£o de m√∫ltiplas imagens)"""
    import requests
    import base64
    import re
    
    # Regex para encontrar todas as URLs de imagem (jpg, png, jpeg, webp)
    # OTIMIZADO: Evita pontua√ß√£o final (.,;!) e captura m√∫ltiplos
    regex = r'(https?://[^\s]+\.(?:jpg|jpeg|png|webp))'
    urls_encontradas = re.findall(regex, mensagem, re.IGNORECASE)
    
    if urls_encontradas:
        # Texto limpo: remove todos os links para n√£o ficar redundante no WhatsApp
        texto_limpo = mensagem
        for url in urls_encontradas:
            # Substitui links seguidos opcionalmente por quebras de linha/espa√ßos
            texto_limpo = re.sub(re.escape(url) + r'[\s\n]*', '', texto_limpo).strip()
            
        logger.info(f"üì∏ Detectadas {len(urls_encontradas)} URLs de imagem. Texto limpo: {texto_limpo[:50]}...")
        
        # 1. Enviar primeiro o TEXTO como mensagem separada (se houver texto)
        if texto_limpo:
            whatsapp.send_text(telefone, texto_limpo)
            # Pequeno delay para a mensagem de texto chegar primeiro
            time.sleep(1.0)
            
        # 2. Enviar cada imagem sequencialmente
        for i, image_url in enumerate(urls_encontradas):
            logger.info(f"‚¨áÔ∏è Baixando imagem [{i+1}/{len(urls_encontradas)}]: {image_url}")
            
            try:
                # Baixar imagem
                img_resp = requests.get(image_url, timeout=15)
                img_resp.raise_for_status()
                
                # Converter para Base64
                img_b64 = base64.b64encode(img_resp.content).decode('utf-8')
                mime = img_resp.headers.get("Content-Type", "image/jpeg")
                
                # Enviar como m√≠dia (sem caption agora, pois o texto j√° foi enviado)
                whatsapp.send_media(telefone, caption="", base64_data=img_b64, mimetype=mime)
                
                # Pequeno delay entre imagens
                if i < len(urls_encontradas) - 1:
                    time.sleep(1.2)
            
            except Exception as e:
                logger.error(f"‚ùå Erro ao baixar/enviar imagem {image_url}: {e}")
                # Fallback: Tentar enviar via URL
                whatsapp.send_media(telefone, media_url=image_url, caption="")
        
        return True
    
    # Mensagem normal (sem imagem)
    max_len = 500
    msgs = []
    
    if len(mensagem) > max_len:
        paragrafos = mensagem.split('\n\n')
        curr = ""
        
        for p in paragrafos:
            if len(p) > max_len:
                if curr:
                    msgs.append(curr.strip())
                    curr = ""
                linhas = p.split('\n')
                for linha in linhas:
                    if len(curr) + len(linha) + 1 <= max_len:
                        curr += linha + "\n"
                    else:
                        if curr: msgs.append(curr.strip())
                        curr = linha + "\n"
            elif len(curr) + len(p) + 2 <= max_len:
                curr += p + "\n\n"
            else:
                if curr: msgs.append(curr.strip())
                curr = p + "\n\n"
        
        if curr: msgs.append(curr.strip())
    else:
        msgs = [mensagem]
    
    try:
        for i, msg in enumerate(msgs):
            whatsapp.send_text(telefone, msg)
            if i < len(msgs) - 1:
                time.sleep(random.uniform(0.8, 1.5))
        return True
    except Exception as e:
        logger.error(f"Erro envio: {e}")
        return False


class WorkerSettings:
    """Configura√ß√£o do ARQ Worker"""
    
    # Conex√£o Redis (mesma do resto do sistema)
    redis_settings = RedisSettings(
        host=settings.redis_host,
        port=settings.redis_port,
        password=settings.redis_password,
        database=settings.redis_db,
    )
    
    # Fun√ß√µes que o worker pode executar
    functions = [process_message]
    
    # Configura√ß√µes de concorr√™ncia e retry
    max_jobs = settings.workers_max_jobs  # M√°ximo de jobs simult√¢neos (5)
    job_timeout = 600  # Timeout de 10 minutos por job (aumentado para pedidos grandes)
    max_tries = settings.worker_retry_attempts  # 3 tentativas
    
    # Configura√ß√µes de sa√∫de e monitoramento
    health_check_interval = 30  # Verifica sa√∫de a cada 30s
    keep_result = 3600  # Mant√©m resultado por 1h
    
    # Nome da fila (Removido para usar o padr√£o arq:queue e casar com o server.py)
    # queue_name = "whatsapp_messages"


async def main():
    """Inicia o worker ARQ"""
    logger.info("üöÄ Iniciando ARQ Worker...")
    logger.info(f"üìä Configura√ß√£o: max_jobs={WorkerSettings.max_jobs}, max_tries={WorkerSettings.max_tries}")
    
    # Configura√ß√£o com a nova API do ARQ 0.26
    from arq.worker import create_worker, func
    
    # Criar worker com as configura√ß√µes
    worker = create_worker(WorkerSettings)
    
    # Rodar o worker
    await worker.async_run()


if __name__ == "__main__":
    asyncio.run(main())
